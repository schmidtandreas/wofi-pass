#!/usr/bin/env bash

VERSION="23.1.1"

set -eu

FLAG_AUTOTYPE=0
FLAG_COPY=0
FLAG_FILEISUSER=0
FLAG_ONLYPASSWORD=0
FLAG_SQUASH=0
FLAG_TYPE=0
FLAG_HELP=0

CMD_COPY="wl-copy"
CMD_TYPE="wtype -"

# We expect to find these fields in pass(1)'s output
PASS_FIELD_USERNAME='username'

function _wofi() {
    wofi "${@}"
}

function _pass() {
    pass "${@}"
}

function _trim() {
    local var="${*}"
    # remove leading whitespace characters
    var="${var#"${var%%[![:space:]]*}"}"
    # remove trailing whitespace characters
    var="${var%"${var##*[![:space:]]}"}"
    printf '%s' "${var}"
}

function parse_fields() {
    local field_list
    local has_username=0
    local -r passname="${1}"
    mapfile -t entries < <(_pass show "${passname}" | tail -n +2 )
    local line=""
    local fields=()

    for entry in "${entries[@]}"; do
        if [[ "${entry}" == "autotype_always" ]]; then
            fields+=("${entry}")
        else
            field="$(echo "${entry}" | cut -d: -f1 -s)"
            [ -n "${field}" ] && fields+=("${field}")
        fi
    done

    field_list+=("password")
    if [ ${FLAG_FILEISUSER} -eq 1 ]; then
        has_username=1
        field_list+=( "${PASS_FIELD_USERNAME}" )
    fi
    for line in "${fields[@]}"; do
        if [ "${line}" = "${PASS_FIELD_USERNAME}" ]; then
            if [ ${has_username} -eq 0 ]; then
                has_username=1
                field_list+=( "${line}" )
            fi
        elif [ "${line}" = "otpauth" ]; then
            field_list+=( "OTP" )
        elif [ "${line}" = "autotype_always" ]; then
            FLAG_AUTOTYPE=1
        else
            field_list+=( "${line}" )
        fi
    done

    if [ ${FLAG_TYPE} -eq 1 ] && [ ${has_username} -eq 1 ]; then
        field_list=("autotype" "${field_list[@]}")
    fi

    printf "%s\n" "${field_list[@]}"
}

function pass_field() {
    local -r passname="${1}"
    shift
    _trim "$(_pass show "${passname}" | tail -n+2 | grep "^${*}:.*$" | cut -d: -f1 -s --complement)"
}

function pass_get() {
    local -r passname="${1}"
    local -r field="${2}"
    if [ "${field}" = "password" ]; then
        _pass show "${passname}" | { IFS= read -r pass; printf %s "${pass}"; }
    elif [ "${field}" = "OTP" ]; then
        _pass otp "${passname}" | tail -n1 | { IFS= read -r pass; printf %s "${pass}"; }
    elif [ ${FLAG_FILEISUSER} -eq 1 ] && [ "${field}" = "${PASS_FIELD_USERNAME}" ]; then
        printf %s "${passname##*/}"
    else
        pass_field "${@}"
    fi
}

function usage() {
    cat <<EOF
    Usage:
    wofi-pass [options]

    Options:
        -a, --autotype    autotype whatever entry is chosen
        -c, --copy=[cmd]  copy to clipboard. Defaults to wl-copy if no cmd is given.
        -f, --fileisuser  use the name of the password file as username
        -h, --help        show this help message
        -s, --squash      don't show field choice if password file only contains password
        -t, --type=[cmd]  type the selection instead of copying to clipboard.
                          Defaults to wtype if no cmd is given.

    wofi-pass version ${VERSION}
EOF
}

get_config_file () {
    local config_base_dir="${XDG_CONFIG_HOME:-"${HOME}/.config"}"
    readonly config_base_dir

    config_files=("${WOFI_PASS_CONFIG:-""}"
                  "${config_base_dir}/wofi-pass/config"
                  "/etc/wofi-pass.conf")

    # return the first config file with a valid path
    for config in "${config_files[@]}"; do
        if [[ -n "${config}" && -f "${config}" ]]; then
            printf "%s" "${config}"
            return
        fi
    done
}

load_config_file () {
    config_file="$(get_config_file)"
    if [[ -n "${config_file}" ]]; then
        #shellcheck source=wofi-pass.conf
        source "${config_file}"
    fi
}

function parse_arguments() {
    OPTS="$(getopt --options ac::fhst:: --longoptions autotype,copy::,fileisuser,help,squash,type:: -n 'wofi-pass' -- "${@}")"
    eval set -- "${OPTS}"
    while true; do
        case "${1}" in
            -a | --autotype) FLAG_AUTOTYPE=1; shift;;
            -c | --copy)
                FLAG_COPY=1
                [ -n "${2}" ] && CMD_COPY="${2}"
                shift 2;;
            -f | --fileisuser) FLAG_FILEISUSER=1; shift;;
            -h | --help) FLAG_HELP=1; shift;;
            -s | --squash) FLAG_SQUASH=1; shift;;
            -t | --type)
                FLAG_TYPE=1
                [ -n "${2}" ] && CMD_TYPE="${2}"
                shift 2;;
            --) shift; break;;
            *) break;;
      esac
    done
}

function exit_if_help_flag_set() {
    if [ ${FLAG_HELP} -eq 1 ]; then
        usage >&2
        exit 0
    fi
}

function verify_flags() {
    if [ ${FLAG_TYPE} -eq 1 ] && [ ${FLAG_COPY} -eq 1 ]; then
        printf "copy and type cannot be used at same time. Please pass only one.\n" >&2
        exit 1
    elif [ ${FLAG_TYPE} -eq 0 ] && [ ${FLAG_COPY} -eq 0 ]; then
        printf "neither -c/--copy or -t/--type passed. Defaulting to copying with %s.\n" "${CMD_COPY}" >&2
    fi
}

function get_passname_from_menu() {
    local -r pass_dir="${PASSWORD_STORE_DIR:-${HOME}/.password-store}"
    local password_files
    password_files="$(find "${pass_dir}" -name "*.gpg" | sed "s|^${pass_dir}\/\(.*\)\.gpg$|\1|" | sort)"
    readonly password_files

    printf "%s" "$(printf '%s\n' "${password_files}" | _wofi --dmenu)"
}

function get_field_from_menu() {
    local field
    local field_count
    local -r passname="${1}"
    mapfile -t field_list < <(parse_fields "${passname}")
    field_count=${#field_list[@]}
    readonly field_list
    readonly field_count
    if [ ${FLAG_SQUASH} -eq 1 ] && [ "${field_count}" -le 1 ]; then
        printf "password"
        FLAG_ONLYPASSWORD=1
    elif [ ${FLAG_AUTOTYPE} -ne 1 ]; then
        printf "%s" "$(printf '%s\n' "${field_list[@]}" | _wofi --dmenu)"
    fi
}

function get_output_cmd() {
    if [ ${FLAG_TYPE} -eq 1 ]; then
        printf "%s" "${CMD_TYPE}"
    else
        printf "%s" "${CMD_COPY}"
    fi
}

function output_autotype() {
    local -r username="${1}"
    local -r password="${2}"
    local -r cmd_output="${3}"
    #TODO: improve autotype handling
    printf '%s\t%s\n' "${username}" "${password}" | ${cmd_output}
}

function output_field() {
    local cmd_output
    local -r passname="${1}"
    local -r field="${2}"
    cmd_output="$(get_output_cmd)"

    if [ ${FLAG_AUTOTYPE} -eq 1 ] || [ "${field}" = "autotype" ]; then
        local username
        local password
        username=$(pass_get "${passname}" "${PASS_FIELD_USERNAME}")
        password=$(pass_get "${passname}" "password")

        # check if we are autotyping a password-only file
        if [ ${FLAG_ONLYPASSWORD} -eq 1 ]; then
            printf '%s\n' "${password}" | ${cmd_output}
        else
            output_autotype "${username}" "${password}" "${cmd_output}"
        fi

    else
        pass_get "${passname}" "${field}" | ${cmd_output}
    fi
}

function main() {
    local passname
    local field

    load_config_file

    parse_arguments "${@}"

    exit_if_help_flag_set

    verify_flags

    passname="$(get_passname_from_menu)"
    [ -n "${passname}" ] || exit

    field="$(get_field_from_menu "${passname}")"

    output_field "${passname}" "${field}"
}

if [[ -z "${WOFI_PASS_TESTING:-""}" ]]; then
    main "${@}"
fi
